---
title: "Akustische Wirkung von Dämpfern"
Author: "ESR"
Date: "November 2015"
output:
  html_document:
    fig_caption: yes
    toc: yes
---
```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(
  message = FALSE, 
  warning = FALSE,
  echo = F,
  fig.width = 12, fig.height= 9,
  dev = 'CairoSVG'
  #,dev='CairoPNG'
)

```

```{r include=FALSE}
#import library and functions
library(jsonlite)
library(dplyr)
library(tidyr)
library(ggplot2)
source('ggplot_templates.R')

#set db connections
library(rmongodb)
# your connection details will likely differ from these defaults
host <- "127.0.0.1"
username <- "esrWR"
password <- "esrWR"
db <- "OBdata"
#connect to mongo
conn <- mongo.create(host=host , db=db)#, username=username, password=password)

```
----

# Einleitung

Dieser Teil der Bericht analysiert die Resultate der postprocessing welche im File `DSPresults.json` enthalten sind. 

**Ziel der Statistische Analyse ist die Wirkung von Schienendämpfern abzuschätzen**


```{r,echo=FALSE, results='hide'}
##Daten Importieren


passby = fromJSON("DSPResults.json")

## Daten für Darstellung vorbereiten
#Die .json Daten werden in einer R `data.frame` umgewandelt so dass gewisse Operationen (Darstellung, #Gruppierungen,...) einfacher werden.

FREQ = c(100, 125,
         160, 200, 250, 315, 400, 500, 630, 800, 1000,
         1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000)
#funktionen zur umwandlung
intervals_to_df = function(colN, l){
  func = function(n){
    df = data.frame(c(interval=n, as.list(setNames(l[[n]],colN))))
    return(df)
  }
  d = do.call(rbind, 
              lapply(setdiff(names(l), c('FAMOS','f')), func)
              )
  return(d)
} 

func1 = function(pb,A){
  f = FREQ
  # crete list o variables attributes
  variables = list(
    #'sel' = list(var = 'sel', colN ='sel.tot'),
    'leq' = list(var = 'leq', colN = 'leq.tot'),
    #'s_sel' = list(var = 'spektrum_sel', colN = paste('sel', f,sep='.')),
    's' = list(var = 'spektrum', colN = paste('leq', f,sep='.'))
  )
  #create list of df each for a given variable
  d = lapply( variables , 
              function(l)intervals_to_df(l$colN, passby[[pb]][[A]][[l$var]])
  )
  # merge list of df to a single df by common interval
  df = Reduce(function(x,y) merge(x,y, all=TRUE, by = 'interval'), d)
  return(df)
}
#
pbNames =  setdiff(names(passby), c('Beschreibung'))
absch = c('Q1','Q2','Q3','Q4')

# spectra and levels
spectWideDf = expand.grid(passby = pbNames, A = absch) %>% rowwise()%>% 
  do(data.frame(passby = as.character(.$passby),
                A = as.character(.$A),
                func1(as.character(.$passby), as.character(.$A))
                )
     )
spectWideDf$A = factor(spectWideDf$A)
# filter

spectWideDf=spectWideDf%>%filter(interval!='vorbei' )

#zugstyp
typDf = data.frame(passby = pbNames) %>% rowwise() %>% 
  do(data.frame(passby = as.character(.$passby),  Zugstyp = passby[[as.character(.$passby)]]$Zugstyp ))

# speed
vDf = expand.grid(passby = pbNames, A = c('Q1','Q4')) %>% rowwise() %>% 
  do(data.frame(passby = as.character(.$passby),
                A = as.character(.$A),
                Zugstyp = passby[[as.character(.$passby)]][['Zugstyp']],
                v  = round(passby[[as.character(.$passby)]][[as.character(.$A)]]$vAv ),
                dv  = round(passby[[as.character(.$passby)]][[as.character(.$A)]]$dv ),
                bogie = 1:length(passby[[as.character(.$passby)]][[as.character(.$A)]][['ti_vi']][2,]),
                vi = passby[[as.character(.$passby)]][[as.character(.$A)]][['ti_vi']][2,], 
                ti = passby[[as.character(.$passby)]][[as.character(.$A)]][['ti_vi']][1,]
                )
     )
vDf$A = factor(vDf$A)
vDf$interval = floor(vDf$bogie/2)
#select bogies that are loc or strange
vDf$bogie.type = sapply(abs(vDf$vi-vDf$v) < 5, function(b)if(b){'Wagen'}else{'Antrieb'})

```

----

#### Abschnittnamen und eingebaute Dämpfern

Es besteht die folgende Relation zwischen Name der Abschnitten und deren eingebaute Dämpfern.

Dämpfer |ValFX Abkürzung| Abkürzung Messung 
--------|---------------|---------------
TATA    | B1            | nicht gemessen 
S&V     | B2            | Q4 
Vossloh | B3            | Q3 
STRAIL  | B4            | Q2 
Ref     | B5            | Q1 

Es iss zu Bemerken dass die Abschnitte sind bei der Messung unterschiedlich als sonst wie im valFX Projekt benannt worden. **Ab jetzt wird die ValFX Abküzung verwendet um die Abschnitten zu unterscheiden**
```{r}
#unbennen der Abschnitten in die data.frame
levels(spectWideDf$A) = c('B5','B4','B3','B2')
levels(vDf$A) = c('B5','B2')
```
----

#### Postprocessing Resultate

Dias postprocessing der Mikrophonsignale liefert **Terzspektren und Gesamtpegel** des Schalldruck fur jede Vorbeifahrt([Details](http://nbviewer.ipython.org/github/e-sr/ValFX/blob/master/AkustischeMessungNiederwangen/SpektrenBerechnen.ipynb)). 

Terzspektren aus den gesamte Signal oder auch Gesamtzug berechnet  werden mit `full` bezeichnete.

Für deie Abschnitte B5 und B2 würden zusätzlich die Spektren Wagenbezogen berechnet.Von wagenmitte der n-te Wagen bis zur Wagenmitte der n+1 Wagen. Diese Spektren werden mit den entsprechende Zahl `n` Bezeichnet. Das war möglich da für diese Abschnitten Lichtschrankensignalen vorhanden sind.

Zusätzliche Informationene  wurden zu jede Vorbeifahrt mithilfe von LS Signalen ([Details](http://nbviewer.ipython.org/github/e-sr/ValFX/blob/master/AkustischeMessungNiederwangen/analyseLS.ipynb))  gewonnen:

- __Zugsgeschwindigkeit__ Nur Vorbeifahrten mit aänliche Geschwindigkeit auf alle Abschnitte wurden 

- __Intevallbezeichnung__ Die Intervalle mit `n` bezeicnet (nicht Gesamtzug) können `Trieb` sowohl `Wagen` Drehgestelle enthalten. Um Intervalle aus ähnlichen Drehgestelle zu vergleichen, müssen die Intervalle jede Vorbeifahrt in `Wagen` , `Trieb/Wagen` oder `Gesamtzug (full)` kategorisiert werden.

- __Zugstyp__ Wurde mithilfe von Achsmuster und Drehgestell abstand entdeckt. Zwei klasen von Zügen sind zu unterscheiden:

    1. Regiozugen; wahrscheinlich handelt sich um einen Domino (Triebwagen-Inowa-Steuerwagen) in doppelte Komposition. Triebdrehgestelle mit einen Abstand von 2.7m ergeben konsistente werte
    2. IC Zügen; diese Zügen  bestehen aus (EWIV, IC2000, Steuerwagen und Re460). Der Anzahl wagen ist variabel.

```{r, eval =F  }

ggplot(data =vDf%>%filter(Zugstyp == 'Regio'& passby==14) ) +
  geom_hline(aes(yintercept = v, group = interaction(passby,A)), color = 'blue', alpha = 0.7, size = 2)+
  geom_point(mapping = aes(x = bogie, y = vi, color =bogie.type, text =bogie.type), size = 3)+
  facet_grid(.~A)+
  ylab('v km/h')+xlab('Drehgestell')+
  scale_y_continuous(breaks = seq(80,150,5))+
  scale_x_continuous(breaks = 1:14 )+
  theme(legend.position="bottom")

#```
#```{r eval = F, fig.height= 4,out.width='500px'}
ggplot(vDf%>%filter(Zugstyp =='IC'& passby == '8') ) +
  geom_hline(aes(yintercept = v, group = interaction(passby,A)), color = 'blue', alpha = 0.7, size = 2)+
  geom_point(mapping = aes(x = bogie, y = vi, color = bogie.type), size = 3)+
  facet_grid(passby*Zugstyp~A)+
  scale_color_discrete()+
  ylab('v km/h')+xlab('Drehgestell')+
  scale_y_continuous(breaks = seq(80,150,5) )+ theme_bw()+theme(legend.position="bottom")
```


```{r}
# kategorisierung von Auswertungsintervalle
X=vDf%>%group_by(passby,A,interval)%>%
  do(data.frame(passby = .$passby, 
                A = as.character(.$A), 
                bogie=as.character(.$bogie),
                nBogies = nrow(.), 
                interval.kat = if(any(.$bogie.type=='Antrieb')){'Antrieb/Wagen'}else{'Wagen'}
  )
  )
X = merge(vDf,X, by=c('passby','A', 'bogie','interval'))

#fill spect df
intervalKat=X%>%filter(nBogies == 2)%>%group_by(passby,A,interval) %>% do(data.frame(interval.kat = .$interval.kat[1]))
spectWideDf = merge( intervalKat, spectWideDf,  by= c('passby','A', 'interval'), all = TRUE)
spectWideDf$interval.kat[is.na(spectWideDf$interval.kat)] = spectWideDf$interval[is.na(spectWideDf$interval.kat)]

## Darstellung Kategorisierung
# ggplot(X) +
#   geom_hline(aes(yintercept = v, group = interaction(passby,A)), color = 'blue', alpha = 0.7, lw = 2)+
#   geom_point(mapping = aes(x = bogie, y = vi, color = bogie.type,shape = interval.kat), size = 4)+
#   facet_grid(passby*Zugstyp~A)+
#   scale_color_discrete()+
#   scale_y_continuous(breaks = seq(80,150,5) )+ theme_bw()
```


```{r  }
# Vorbereiten der daten in long format
#add speeds
spectWideDf = merge( vDf[,c('passby','A', 'v','dv')]%>%group_by(passby,A)%>%do(.[1,]),
                  spectWideDf,  by=c('passby','A'), all.y = TRUE)
#add zugstyp
spectWideDf = merge( typDf, spectWideDf,  by = c('passby'),all.y = TRUE)

spectDf = spectWideDf %>% gather('var','level', leq.tot:leq.8000) %>% separate(var , c('var','band'))

#remove unuse Frequencies
FREQ = c(#100, 125,
         160, 200, 250, 315, 400, 500, 630, 800, 1000,
         1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000)
spectDf = spectDf %>%filter(band != "100" & band !="125")

save(list=c('spectDf','FREQ'),file = 'passby_SPL_DF.Rdata')
```

In die nächste Graphik ist die mittlere Geschwindigkeit jede Vorbeifahrt auf die Abschnitte B5 und B2 dargestellt. Vorbeifahrten mit grosse Geschwindigkeitdifferenzen auf die Abschnitte B2 und B5 wurden Verworfen. In dieser Graphik sind nur die Gültige Vorbeifahrten dargestellt.

```{r, fig.cap = 'Mittlere Zugsgeschwindigk', out.width='500px'}
ggplot(spectDf) + 
  geom_point(mapping = aes(x = passby, y = v, shape = A, color = Zugstyp), size =3)+
  ylab('v km/h')+
  scale_y_continuous(breaks = seq(80,150,5) )+ theme_bw()+theme(legend.position="bottom")
  
```

----

#### Sonst

Quellencode diesem Teil ist im file [StatAusw.md](https://github.com/e-sr/ValFX/blob/master/AkustischeMessungNiederwangen/StatAuswe.Rmd) zu sehen.

----

# Darstellungen von Spektren und Levels

Dieser Abschnitt dient um einen Gefühl mit die gemessene/ausgewertete daten zu bekommen.

Dazu wird die Streuung der berechnete Spektren bzw. Levelsuntersucht.

- innerhalb die gleichen pass-by, indem unterschiedliche Auswertung Intervalle verglichen werden
- innerhalb verschiedene pass-by der gleiche Zugs bzw. Geschwindigkeit Kategorie

**Spektern und Gesamtpegeln sind in dBA angegeben**

## Abschnitten B5 und B2

Für diese Abschnitte sind Spektren Wagenbezogen berechnet worden. Es ist somit möglich Spektren innerhalb die gleichen pass-by zu vergleichen. Passby  10,13 und 8 sind nicht dargestellt da langsämer gefahren sind. Alle andere passby hatten eine geschwindigkeit von ungefähr 140 km/h 


### Levels von IC Züge für Intervalle der kategorie `Wagen`

```{r  fig.width = 14, fig.height=7, out.width='800px'}
ggplot(droplevels(spectDf%>%
                    filter(band =='tot'& interval.kat=='Wagen' & (A =='B5'| A=='B2') & Zugstyp == 'IC' ))%>%
         filter(passby != "10"& passby != "13" & passby != "8"),
       aes(x = passby, y = level)
) +
  geom_boxplot(alpha = 0.7)+
  geom_point(aes(color = v),size =4,alpha = 0.6,position = "jitter")+
  ylab('Level dBA')+
  facet_grid( .~ A)+
  scale_y_continuous(breaks = seq(80,150,1) )

```

**Diskussion**:

- eine viel grössere Streuung als erwartet ist zu sehen. Zwischen unterschiedliche Intervalle der gleichen pass-by sind variationen bis 5 dB zu sehen

- Die Variabilität innerhalb ein einziges Zug ist Grösser als die Variabilität Zwischen verschiedene pass-by

- zwischen unterschiedliche pass-by (gleuche Zugstyp mit ähnlichen Geschwindigkeiten) sind bis zu 2-3dB Unterschieden zu sehen

- die Streuung ist nicht konstant für ein gegebens passby auf beide Abschnitte.Damit ist es nichtmöglich die streuung zu Erklären aufgrund unterschidelich Radrauheiten. 

### Spektren von IC Züge für Intervalle der kategorie `Wagen`

```{r fig.width = 14, fig.height=6, out.width='1000px'}
SpectPlot(FREQ) + 
  geom_line(data= spectDf%>%
              filter(band!='tot'& interval.kat=='Wagen' &  (A =='B5'| A=='B2') & Zugstyp == 'IC' )%>%
              filter(passby != 10& passby != 13 & passby != 8),
            mapping = aes(x = as.numeric(band), y = level, group = interaction(passby, A, interval, var), color = passby ),
            size = 1.5, alpha=0.5) +
  scale_y_continuous(breaks = seq(20,150,5) )+
  ylab('Level dBA')+
  facet_grid(interval.kat ~ A)

```
Bemerkungen:

- Die Spektren weisen ein sehr hohen tonales Anteil bei $2000 Hz$ auf. Eine mögliche Erklärung ist der  höhe Rauheitswert bei $2\,cm$ Wellenänghe welche umgewandelt in Frequenz (für $140 km/h$) betragt $`r v= 140/3.6; round(v/0.02,-1) ` \, Hz$.



### Spektren und Levels von Regio Züge
```{r eval=F, fig.width = 14, fig.height=10, out.width='800px'}
ggplot(droplevels(spectDf%>% filter(band =='tot'& interval.kat!='full'& interval.kat!='vorbei' & (A =='B5'| A=='B2') & Zugstyp == 'Regio' )),aes(x = passby, y = level)) +
  #geom_boxplot(alpha = 0.7)+
  geom_point(aes(color = v), size =4,alpha = 0.6)+
 facet_grid( interval.kat~ A)+
  ylab('Level dBA')+
  scale_y_continuous(breaks = seq(80,150,1) )
  
```

Levels von Regio Züge für Intervalle der Kategorie `Wagen` und `Trieb/Wagen` sind nicht angezeigt da diese Züge nur aus 6 Wagen bestehen, davon 2 mit Triebfahrzeuge und deshalb hat man innerhalb ein einziges Zug nur wenige Intervalle zu Vergleichen. 

Eine sehr grosse Variabilität der Schalldruckpegel wurde wie für IC Züghe auch festgestellt.

die spektern Spektren  für Intervalle der kategorie `Trieb/Wagen` sind im folgende Bild dragestellt

```{r  fig.width = 14, fig.height=6, out.width='1000px'}
SpectPlot(FREQ) + 
  geom_line(data= spectDf%>%
              filter(band!='tot'& interval.kat=='Wagen' &  (A =='B5'| A=='B2') & Zugstyp == 'Regio' ),
            mapping = aes(x = as.numeric(band), y = level, group = interaction(passby, A, interval, var), color = passby ),
            size = 1.5, alpha=0.5) +
  ylab('Spektrum dBA')+
  scale_y_continuous(breaks = seq(20,150,5) )+
  facet_grid(interval.kat ~ A)

```

Diskussion:

- die höhe tonalität bei 2000 Hz ist ausgeprägt wie beim IC Wagen.
- Diese Züghe sind lauter als IC Züghe
- dazu ist eine grose Streuung beit tiefe Frequenzen

## Alle Abschnitte

Die Spektren berechnet aus Intervalle `full`  werden hier gezeigt. Da für die Abschnitte B3 und B4 keine LS eingesetzt wurde ist es nicht möglich drehgestellweise auszuwerten. Den Anzahl von Levels ist deswege gering, jedoch gelten die bereits gemachten Bemerkungen über variabilität zwischen unterschiedliche Züghe der gleiche Klasse  auch für die Abschnitten B3 und B4.

```{r fig.width = 14, fig.height=10, out.width='1000px'}
SpectPlot(FREQ) + 
  geom_line(data= spectDf%>%
              filter(band!='tot'& interval.kat=='full' &  (A =='B3'| A=='B4')),
            mapping = aes(x = as.numeric(band), y = level, group = interaction(passby, A, interval, var), color = passby ),
            size = 1.5, alpha=0.5) +
  scale_y_continuous(breaks = seq(20,150,5) )+
  ylab('Level dBA')+
  facet_wrap(Zugstyp ~ A,scales='free_x')

```
<!--
## Leq vs. Geschwindigkeit für  IC Züghe

Für IC Züghe sind genügende Levels berechnetworden um sinnvoll eine  regression der Level Gegnüber die geschwindigkeit darzustellen. Die Frage die man beantworten will ist :

`Ist die Variabilität erklart aus die Geschwindigkeitunterschiede?`

Die Antwort ist`nein` und war  schon in Früheren Abbildungen zu raten. Die nächste Graphik, wo Leq Werte gegen die Geschwindigkeit dargestellt werden, versucht die Frage genauer zu bentworten.

Man erwartet zunehmender Leq mit zunehmender Geschwindigkeit ($leq \propto log_{10}v$).
-->

```{r eval = FALSE, fig.width = 14, fig.height=10, out.width='800px'}
ggplot(droplevels(spectDf%>%filter(!is.na(v)& band=='tot'& Zugstyp == 'IC')),
        aes(x = v, y = level)) + 
  #geom_boxplot(mapping = aes(x = A, y = level, color = interval)) +
  geom_point(aes(x = v, y = level, color =passby),size =3,alpha = 0.6)+
  stat_smooth(method = "lm", formula = y ~ 1+log(x), se = FALSE,size = 1,alpha = 0.5)+
  facet_grid(A~interval.kat)+
  ylab('Level dBA')+xlab('v, km/h')+
  scale_y_continuous(breaks = seq(80,150,5) )+ theme_bw()+ theme(legend.position="bottom")
  
```

----

#Fazit

- wirkung quantifizieren
- variabilität von akustische messung. grund rauheit? zu gross um kleine unterschiede zu messen.
- die berechnete werte könnten somit zufall sein
- ruhait korrektur nich möglich sihe rauheit 

...
# TODO
- capitoli
- fazit
- 
- Controllare un po tutto
- Link
- README
